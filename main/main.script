local constants = require("main/constants")

local player_positions = {}
local players = {}

local INPUT_KEY_UP = 1
local INPUT_KEY_DOWN = 2
local INPUT_KEY_LEFT = 3
local INPUT_KEY_RIGHT = 4
local player_input_keys = {}

local recording = 0

-- Takes a 1 based array index, creates a zero based 2d tile coordinate
local function index_to_coords(index, width)
    local x = math.floor((index-1) % width)
    local y = math.floor((index-1) / width)
    return x, y
end

-- Takes a zero based 2d tile coordinate, and the level width (tiles)
-- Returns a 1 based array index 
local function coords_to_index(x, y, width)
    return y * width + x + 1
end

-- Takes a zero based 2d tile coordinate, returns a 2d screen coordinate
local function coords_to_screen(x, y)
    local scrx = constants.TILE_SIZE * x + constants.TILE_SIZE / 2
    local scry = constants.TILE_SIZE * y + constants.TILE_SIZE / 2
    return scrx, scry
end

-- Takes a 2d screen coordinate, returns a zero based 2d tile coordinate
local function screen_to_coords(x, y)
    return math.floor(x / constants.TILE_SIZE), math.floor(y / constants.TILE_SIZE)
end

function init(self)
    msg.post(".", "acquire_input_focus")
    msg.post("levels#level01", "load")
    
    self.display_width = sys.get_config("display.width")
    self.display_height = sys.get_config("display.height")
end

function update(self, dt)
	local game_state = constants.GAME_STATE_INGAME
	if game_state == constants.GAME_STATE_INGAME then
		local pos = go.get_position(players[1])
		pos = pos - vmath.vector3(self.display_width/4, self.display_height/4, 0)
		-- make sure we're aligned to pixels, for the tiles not to get messed up
		--pos.x = round(pos.x)
		--pos.y = round(pos.y)
		--go.set_position(pos, "/camerago#camera")
	end
end


local function find_start_positions()
	local x, y = coords_to_screen(2,9)
	player_positions[1] = vmath.vector3(x, y, 0.2)
end

local function initplayer(playerid, pos)
    players[playerid] = factory.create("#playerfactory", player_positions[playerid], vmath.quat_rotation_z(0), {}, vmath.vector3(1,1,1) )
    
    player_input_keys[playerid] = {}
    player_input_keys[playerid][INPUT_KEY_UP] = hash("up")
    player_input_keys[playerid][INPUT_KEY_DOWN] = hash("down")
    player_input_keys[playerid][INPUT_KEY_LEFT] = hash("left")
    player_input_keys[playerid][INPUT_KEY_RIGHT] = hash("right")
end

-- Implementation inspired by http://stackoverflow.com/a/1557247/468516
local function spiral_loop(X, Y, fn)
	local x = 0
	local y = 0
	local dx = 0
	local dy = -1
	local s = 0
	local ds = 2
	local max = math.max(X, Y)
	local maxsq = max*max
	local middlex = math.floor(X/2)
	local middley = math.floor(Y/2)
	for i = 0, maxsq-1 do
		if math.abs(x) <= X and math.abs(y) <= math.floor(Y/2) then
			fn(x+middlex, y+middley)
		end
		if i == s then
			dx, dy = -dy, dx
			s, ds = s + math.floor(ds/2), ds + 1
		end
		x, y = x+dx, y+dy
	end
end

local stencil_anim_count = 0

local function stencil_anim_done(self, url, property)
	stencil_anim_count = stencil_anim_count - 1
	if stencil_anim_count == 0 then
		print("disable_stencil_mask")
		msg.post("@render:", "disable_stencil_mask")
		
		--print("STOPPED RECORDING")
		--msg.post("@system:", "stop_record")
	end
end

local function do_screen_fade_in(width, height, startpos)
    local num_tiles_x = math.ceil(width / constants.TILE_SIZE * 0.5)
    local num_tiles_y = math.ceil(height / constants.TILE_SIZE * 0.5)
    
    local screen_offset = startpos - vmath.vector3(width / 4, height / 4, 0)
    -- the distance from center of screen to the corner of the screen
    local max_dist = vmath.length( vmath.vector3(width / 4, height / 4, 0) )
    
    local tiles = {}
    
    local maxcount = num_tiles_x*num_tiles_y-1
    
    stencil_anim_count = 0
    
    
	--print("RECORDING")
	--msg.post("@system:", "start_record", { file_name = "/Users/mawe/defold_rec.ivf" } )
    
    local count = 0
    spiral_loop(num_tiles_x, num_tiles_y,
    	function(x, y)
            local scrx = x * constants.TILE_SIZE + constants.TILE_SIZE/2 + screen_offset.x
            local scry = y * constants.TILE_SIZE + constants.TILE_SIZE/2 + screen_offset.y
            local pos = vmath.vector3(scrx, scry, 0.8)
            local tile = factory.create("#stencil_tile_factory", pos, vmath.quat_rotation_z(0), {}, vmath.vector3(0, 0, 0) )
            tiles[tile] = tile
            
            stencil_anim_count = stencil_anim_count + 1
            
            -- spiral
            local unitcount = count/maxcount
            --go.animate(tile, "scale", go.PLAYBACK_ONCE_FORWARD, 1, go.EASING_LINEAR, 0.4 - 0.35 * unitcount, count * 0.008, stencil_anim_done)
            
            -- random
            --go.animate(tile, "scale", go.PLAYBACK_ONCE_FORWARD, 1, go.EASING_LINEAR, 0.2 + math.random() * 0.2, math.random() * 0.3, stencil_anim_done)

			-- bottom left to top right
			local manhattandist = (x + y) / (num_tiles_x + num_tiles_y)
			go.animate(tile, "scale", go.PLAYBACK_ONCE_FORWARD, 1, go.EASING_LINEAR, 0.5, manhattandist * 0.8, stencil_anim_done)
            
            count = count + 1
    	end)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("proxy_loaded") then
        msg.post(sender, "init")
        msg.post(sender, "enable")
        
    	find_start_positions()
    
        go.delete_all(players)
        players = {}
        initplayer(1, vmath.vector3(constants.TILE_SIZE * 2 + constants.TILE_SIZE/2, constants.TILE_SIZE * 9 + constants.TILE_SIZE/2, 0.2) )
        
        -- focus camera on player
        msg.post("/camerago#camera", "acquire_camera_focus")

        do_screen_fade_in(self.display_width, self.display_height, player_positions[1])
    end
end


function on_input(self, action_id, action)
	local playerid = 1
    if action_id == player_input_keys[playerid][INPUT_KEY_UP] then
    	msg.post(players[playerid], constants.PLAYER_MESSAGE_ACCELERATE)
    elseif action_id == player_input_keys[playerid][INPUT_KEY_DOWN] then
    	msg.post(players[playerid], constants.PLAYER_MESSAGE_BRAKE)
    elseif action_id == player_input_keys[playerid][INPUT_KEY_LEFT] then
    	msg.post(players[playerid], constants.PLAYER_MESSAGE_LEFT)
    elseif action_id == player_input_keys[playerid][INPUT_KEY_RIGHT] then
    	msg.post(players[playerid], constants.PLAYER_MESSAGE_RIGHT)
    	
    elseif action_id == hash("1") and action.pressed then
    	if recording == 0 then
    		print("RECORDING")
    		msg.post("@system:", "start_record", { file_name = "/Users/mawe/defold_rec.ivf" } )
    		recording = 1
    	else
    		print("STOPPED RECORDING")
    		msg.post("@system:", "stop_record")
    		recording = 0
    	end
    end
end
