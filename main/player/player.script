local autonomous = require("main/scripts/autonomous")
local constants = require("main/scripts/constants")
local util = require("main/scripts/util")
local waypoint = require("main/scripts/waypoint")

local SPRITE_ROTATION = 16 -- since the sprite is directed in positive y, and not positive x

go.property("ai", false)
go.property("debug", false)




function init(self)
	-- car properties
	self.traction = 1.0
	self.acceleration_multiplier = 1.0
	self.brake_multiplier = 1.0
	self.brakes = 2.0
	self.maxspeed = 250 --150.0
	-- 
    self.speed = 0.0
    self.acceleration = 20
    self.brakes = 15
    self.enginebrake = 0.975
    self.turnspeed = math.pi -- rad /seconds
    self.turndirection = 0
    
    self.touching = {}
    self.tumble_timer = 0 
    self.tumble_direction = 0 
    
    self.angle = SPRITE_ROTATION
    self.radangle = util.angle_to_rad(self.angle)
    self.direction = util.get_direction_from_angle(self.angle)
    self.position = go.get_position(".")
    
    self.debug = true
    
    self.vehicle = autonomous.create({position = self.position, maxspeed = self.maxspeed, radius = 32})
    
    self.waypointindex = 0    
end

function update(self, dt)

	-- UPDATE
	self.vehicle.pause = self.pause
	autonomous.update(self.vehicle, dt)
	
	go.set_position(self.vehicle.position, ".")
	self.position = self.vehicle.position
	
	
	-- ROTATION
	self.direction = vmath.normalize(self.vehicle.velocity)
	local rotation = vmath.quat_from_to(vmath.vector3(0,1,0), self.direction)
	go.set_rotation( rotation, ".")
	
	
	-- CAMERA
	local display_width = 800
	local display_height = 600
	local camerapos = self.position - vmath.vector3(display_width/4, display_height/4, 0)
	go.set_position(camerapos, "/common/camera#camera")
	
	-- DEBUG
	if self.debug then
		autonomous.debug(self.vehicle)
	end
end

function update2(self, dt)

	-- TUMBLING
	if self.tumble_timer == 0 and self.turndirection ~= 0 then
		local message = self.touching[constants.PHYSICS_GROUP_OIL]
		if message ~= nil then
			self.tumble_timer = constants.TIMER_TUMBLE
			self.tumble_direction = self.turndirection
		end
	end

	-- POSITION
	self.position = self.position + self.speed * dt * self.direction
	local visual_position = self.position
	go.set_position(visual_position, ".")
	
	-- CAMERA
	local display_width = 800
	local display_height = 600
	local camerapos = visual_position - vmath.vector3(display_width/4, display_height/4, 0)
	go.set_position(camerapos, "/common/camera#camera")
	
	-- SPEED
	if self.tumble_timer == 0 then 
		self.speed = self.speed * self.enginebrake
	end
	if self.speed > self.maxspeed then
		self.speed = self.maxspeed
	elseif self.speed < self.maxspeed * -0.5 then
		self.speed = self.maxspeed * -0.5
	elseif math.abs(self.speed) < 0.095 then
		self.speed = 0
	end
		
	-- ROTATION
	if self.tumble_timer > 0 then
		local unit = self.tumble_timer / constants.TIMER_TUMBLE
		self.tumble_timer = self.tumble_timer - dt
		if self.tumble_timer < 0 then
			self.tumble_timer = 0
			self.tumble_direction = 0
		end
		go.set_rotation( vmath.quat_rotation_z( self.radangle - math.pi/2 + -self.tumble_direction * unit * (math.pi*2) ), ".")
	elseif self.turndirection ~= 0 then
    	if self.speed >= 0 then
			self.radangle = self.radangle + self.turndirection * self.turnspeed * dt
		else
			self.radangle = self.radangle + -1 * self.turndirection * self.turnspeed * dt
		end
		self.radangle = self.radangle % (2.0 * math.pi) 
		self.angle = util.rad_to_angle(self.radangle)
		
    	self.direction = util.get_direction_from_angle(self.angle)
    	--self.direction = util.get_direction_from_rad(self.radangle)
    	go.set_rotation( vmath.quat_rotation_z( util.angle_to_rad(self.angle-SPRITE_ROTATION) ), ".")
    	--go.set_rotation( vmath.quat_rotation_z( self.radangle - math.pi*0.5, ".") )
	end
	
	self.turndirection = 0
	self.touching = {}
	
    if self.debug then
       -- msg.post("@render:", "draw_line", {start_point = self.position, end_point = self.position + self.direction * self.speed, color = vmath.vector4(1,1,1,1)})
       --msg.post("@render:", "draw_line", {start_point = self.rc_from, end_point = self.rc_to, color = vmath.vector4(1,1,1,1)})
       --msg.post("@render:", "draw_line", {start_point = self.rc_hit, end_point = self.rc_hit + self.rc_normal * 64, color = vmath.vector4(0,1,1,1)})
    end
    
    --self.rc_from = self.position + vmath.vector3(64, 0, 0)
    --self.rc_to = self.position
    --physics.ray_cast(self.rc_from, self.rc_to, { hash("track") } )
end

function on_message(self, message_id, message, sender)
    if message_id == hash("ray_cast_response") then 
        return
    end
    
	if message_id == constants.PLAYER_MESSAGE_PAUSE and message.pressed then
    	self.pause = not self.pause
    end
    if message_id == constants.PLAYER_MESSAGE_ACCELERATE then    
    	self.speed = self.speed + self.acceleration * self.acceleration_multiplier
    elseif message_id == constants.PLAYER_MESSAGE_BRAKE then
    	self.speed = self.speed - self.brakes * self.brake_multiplier
    elseif message_id == constants.PLAYER_MESSAGE_LEFT then
    	self.turndirection = 1
    elseif message_id == constants.PLAYER_MESSAGE_RIGHT then
    	self.turndirection = -1
    elseif message_id == constants.PHYSICS_MESSAGE_CONTACT then 
        --print("Message " .. tostring(message_id))
        if message.group == constants.PHYSICS_GROUP_OIL then
        	self.touching[constants.PHYSICS_GROUP_OIL] = message
        elseif message.group == constants.PHYSICS_GROUP_TRACK then
        	--print("Message " .. tostring(message_id))
        	--pprint(message)
        end
    elseif message_id == constants.LEVEL_MESSAGE_INIT then
    	autonomous.set_waypoints(self.vehicle, waypoint.get_waypoints(), 1)
    end
end
