local constants = require("main/scripts/constants")
local playerinput = require("main/scripts/playerinput")
local screenfade = require("main/scripts/screenfade")
local waypoint = require("main/scripts/waypoint")
local util = require("main/scripts/util")
local debugutil = require("main/scripts/debugutil")
local trainer = require("main/scripts/trainer")

local players = {}

local trackradius = 3 * 32 * 0.5 - 10 -- from autonomous.lua
        
local trainer_runs = {}
local trainer_current_run = {}
local trainer_current_time = 0
local trainer_best_run = 0 -- index into the trainer runs
local trainer_best_run_time = 1000000 -- the currently best time
local trainer_run_count = 0
local trainer_waypoints = {}
local trainer_show_last_number_of_runs = 10
local trainer_waypoint_reached = 0 -- what is the highest index reached?
local trainer_segments_visited = 0

local trainer_best_run_data = nil

local level_maxspeed = 250

local function cleanup_waypoints(self, waypoints)
    for i = 1, #waypoints do
        local index = i
        
        local segment_prev = waypoint.get_segment(waypoints, index-1, index)
        local segment_next = waypoint.get_segment(waypoints, index, index+1)
        local entering_curve_scale = vmath.length_sqr(segment_prev) > vmath.length_sqr(segment_next) and 1 or -1
        local curviness = waypoint.get_curviness(waypoints, index, 150)
        local normal = vmath.normalize(vmath.vector3(-segment_prev.y, segment_prev.x, 0))
        
        if waypoints[index].offset ~= nil then
            print("offset before", waypoints[index].offset)
        end
        
        local dist = math.random()
        local angle = math.pi * 2 * math.random()
        local rand_offset = 0 * dist * vmath.vector3(math.cos(angle), math.sin(angle), 0)
        
        local curvescale = math.max(0, (1 - curviness/math.pi) - 1)
        waypoints[index].offset = normal * trackradius * curvescale * entering_curve_scale + rand_offset
        
        waypoints[index].speed = 40 --level_maxspeed - level_maxspeed * curvescale
        
        print("segment_next", segment_next)
        print("normal", normal)
        print("entering_curve", entering_curve_scale)
        print("curvescale", curvescale)
        print("offset after", waypoints[index].offset)
    end
end

local function modify_waypoints(self, waypoints, maxspeed)
    if self.trainer then
        local index = 0
        local lower_speed = 0
        local speed_lower_limit = 60
        
        print("modify_waypoints")
        
        if trainer_waypoint_reached == 0 or trainer_waypoint_reached == #waypoints then
            print("  lap case")    
            index = math.floor(math.random() * (#waypoints-1)) + 1
            
        else
            print("  wp case")
            
            local countback = 6
			local r = math.random()
			index = trainer_waypoint_reached - math.floor(r * countback)
			if index < 1 then
			    index = index + #waypoints
			end
			
			print("trainer_waypoint_reached", trainer_waypoint_reached)
            print("index", index)
			
            if trainer_waypoint_reached == 1 then
                print("trainer_waypoint_reached / countback", trainer_waypoint_reached, countback)
            end
            
            local found = 0
            for i = trainer_waypoint_reached, trainer_waypoint_reached - countback, -1 do
                local ii = i
                if i < 1 then
                    ii = i + #waypoints
                end
                local speed = waypoints[ii].speed
                if speed == 0 or speed > speed_lower_limit then
                    index = ii
                    break
                end
            end
		    
		    lower_speed = 1
        end
        
        --local dist = math.random()
        --local angle = math.pi * 2 * math.random()
        --waypoints[index].offset = trackradius * dist * vmath.vector3(math.cos(angle), math.sin(angle), 0)
        
        --index = 1
        
        local segment_prev = waypoint.get_segment(waypoints, index-1, index)
        local segment_next = waypoint.get_segment(waypoints, index, index+1)
        local entering_curve_scale = vmath.length_sqr(segment_prev) > vmath.length_sqr(segment_next) and 1 or -1
        local curviness = waypoint.get_curviness(waypoints, index, 150)
        local normal = vmath.normalize(vmath.vector3(-segment_prev.y, segment_prev.x, 0))
        
        if waypoints[index].offset ~= nil then
            print("offset before", waypoints[index].offset)
        end
        
        
        local dist = math.random()
        local angle = math.pi * 2 * math.random()
        local rand_offset = 10 * dist * vmath.vector3(math.cos(angle), math.sin(angle), 0)
        
        local curvescale = math.max(0, (1 - curviness/math.pi) - 1)
        waypoints[index].offset = normal * trackradius * curvescale * entering_curve_scale + rand_offset
        
        print("segment_next", segment_next)
        print("normal", normal)
        print("entering_curve", entering_curve_scale)
        print("curvescale", curvescale)
        print("offset after", waypoints[index].offset)
        
        if lower_speed ~= 0 then
            local speed = waypoints[index].speed
            if speed == 0 then
                waypoints[index].speed = maxspeed * 0.9
                print(string.format("set maxspeed[%d] = %f", index, waypoints[index].speed))
            elseif speed > maxspeed then
                waypoints[index].speed = waypoints[index].speed * 0.9
                print(string.format("set speed[%d] = %f", index, waypoints[index].speed))
            elseif speed > speed_lower_limit  then
                waypoints[index].speed = waypoints[index].speed * 0.95
                print(string.format("speed[%d] = %f", index, waypoints[index].speed))
            end
        else
            waypoints[index].speed = waypoints[index].speed * 1.10
            print(string.format("increase speed[%d] = %f", index, waypoints[index].speed))
        end
    end
end

local function print_wps(index, waypoints)
    for i = 1, #waypoints do
        local s = (i == index) and "*" or ""
        
        print(string.format("%g: spd: %g %s", i, math.floor(waypoints[i].speed), s))
    end
end

local function reset_waypoints(self, waypoints)
    print_wps(trainer_waypoint_reached, waypoints)
    
    waypoint.set_waypoints(waypoints)
end

function init(self)
    msg.post(".", "acquire_input_focus")
    msg.post("/common/camera#camera", "acquire_camera_focus")
        
    self.pause = false
    self.debug = true
    self.trainer = tonumber(sys.get_config('trainer.enable', 0))
    
self.trainer = 1

	playerinput.setup()
	
    table.insert(players, go.get_id("/player1"))
    
    self.display_width = sys.get_config("display.width")
    self.display_height = sys.get_config("display.height")
    
    --screenfade.do_screen_fade_in(self.display_width, self.display_height, go.get_position(players[1]))
	msg.post("@render:", "disable_stencil_mask")
	
	local pos = go.get_position(players[1])
	local tile_pos_x, tile_pos_y = util.screen_to_coords(pos.x, pos.y)
	self.waypoints = waypoint.find_route("#tilemap", "waypoints", {tile_pos_x+1, tile_pos_y+1}, {0, 1})
	
    local waypoints = nil
    
    if self.trainer then
        local levelname = sys.get_config('trainer.level', 'level01')
        levelname = "main/levels/" .. levelname .. ".wp.json"
        waypoints = waypoint.load_waypoints(levelname)
        
        if waypoints ~= nil then
	        trainer_segments_visited = #waypoints
	        trainer_waypoint_reached = #waypoints
	    end
    end
    
    if waypoints == nil then
        waypoints = {}
	    -- add pos, offset and speed
		for _,wp in ipairs(self.waypoints) do
			table.insert(waypoints, { pos = util.coords_to_screen_vector(wp[1]-1, wp[2]-1), offset = vmath.vector3(0,0,0), speed = 0 } )
		end
		
		cleanup_waypoints(self, waypoints)
    end
    self.waypoints = waypoints
    
    trainer_waypoints = util.deepcopy(self.waypoints)
    reset_waypoints(self, trainer_waypoints)
	
	msg.post(players[1], constants.LEVEL_MESSAGE_INIT)
	
	if self.trainer then
	   self.start_position = go.get_position(players[1])
	   self.start_rotation = go.get_rotation(players[1])
	   
	   trainer_best_run_data = trainer.load_data("main/levels/trainerrun.json")
	end
end

function final(self)
	msg.post(".", "release_input_focus")
end

local function reset_level(self, maxspeed)

    if self.trainer then
        trainer_current_time = 0
        
        -- change the track
        trainer_waypoints = util.deepcopy(self.waypoints)
        modify_waypoints(self, trainer_waypoints, maxspeed)
        reset_waypoints(self, trainer_waypoints)
        
        -- reset the players
        go.set_position(self.start_position, players[1])
        go.set_rotation(self.start_rotation, players[1])
        msg.post(players[1], constants.PLAYER_MESSAGE_RESET, {})
        msg.post(players[1], constants.LEVEL_MESSAGE_INIT, {})
    end
end




function render_waypoints(waypoints)
    for i = 1, #waypoints do
        local wp1 = waypoints[i]
        local wp2 = waypoints[i % #waypoints + 1]
        local color = i / #waypoints
        msg.post("@render:", "draw_line", {start_point = wp1.pos, end_point = wp2.pos, color = vmath.vector4(color, color,1,1)})
        
        if wp1.offset ~= nil then
            msg.post("@render:", "draw_line", {start_point = wp1.pos, end_point = wp1.pos + wp1.offset, color = vmath.vector4(1,1,1,1)})
        end
        if wp1.speed ~= nil then
            local u = (i % 3) / 3
            local offset = vmath.vector3(u*10, u, 0)
            msg.post("@render:", "draw_line", {start_point = wp1.pos + offset, end_point = wp1.pos + offset + vmath.vector3(-1,1,0) * wp1.speed, color = vmath.vector4(1,1,0,1)})
        end
    end
end

function update(self, dt)
	if self.debug then
	   render_waypoints(self.waypoints)
    end
    
    if self.trainer then
        
        if not self.pause then
	        trainer_current_time = trainer_current_time + dt
	        if trainer_best_run ~= 0 and trainer_current_time > trainer_best_run_time then
	            -- if the run took too long, abort
	            msg.post("#", constants.TRAINER_MESSAGE_FAILED, { reason = "Lap took too long", waypoint = 0, time = trainer_current_time, speed = 0, numsegments = 0 })
	        end
	    end
        --if trainer_best_run ~= 0 then
        if trainer_best_run_data ~= nil then
            --render_trainer_run(trainer_runs[trainer_best_run].data)
            trainer.render_trainer_data(trainer_best_run_data)
        end
    end
end


function on_message(self, message_id, message, sender)
    if message_id == constants.RECORD_MESSAGE_PLAYER_POSITION then
        if self.trainer then
	        --print(message_id)
	        --pprint(message)
	        table.insert(trainer_current_run, message)
	    end
	elseif message_id == constants.LEVEL_MESSAGE_LAP_FINISHED then

        -- If all players have finished, and the timer has run out
        if self.trainer then
            trainer_run_count = trainer_run_count + 1
             
            table.insert(trainer_runs, { number = trainer_run_count, time = message.lap_time, data = trainer_current_run})
            trainer_waypoint_reached = #trainer_waypoints
            trainer_segments_visited = #self.waypoints
            
            if message.lap_time < trainer_best_run_time then
                trainer_best_run = trainer_run_count
                trainer_best_run_time = message.lap_time
                trainer_best_run_data = trainer_current_run
                self.waypoints = util.deepcopy(trainer_waypoints)
                
                print("New best lap found. Using as seed:")
                print_wps(trainer_waypoint_reached, self.waypoints)
                print("<- -")
                
                local levelname = sys.get_config('trainer.level', 'level01')
                levelname = "main/levels/" .. levelname .. ".wp.json"
                waypoint.save_waypoints(levelname, trainer_waypoints)
                
                print("trainer_segments_visited", trainer_segments_visited)
        
            end
            
            trainer_current_run = {}
            
            print("TRAINER RUN", trainer_run_count, "BEST:", trainer_best_run_time, trainer_best_run)
            
            if #trainer_runs > trainer_show_last_number_of_runs then
	            if (trainer_run_count - trainer_show_last_number_of_runs) ~= trainer_best_run then
	                trainer_runs[trainer_run_count - trainer_show_last_number_of_runs] = nil
	            end
            end
            
            reset_level(self, 0)
        end
    elseif message_id == constants.TRAINER_MESSAGE_FAILED then
        trainer_run_count = trainer_run_count + 1
        print(string.format("TRAINER RUN (failed) %d, %s, t: %f, wp: %d, spd: %f", trainer_run_count, message.reason, message.time, message.waypoint, message.speed))
        
        table.insert(trainer_runs, { number = trainer_run_count, time = message.lap_time, data = trainer_current_run})

        if #trainer_runs > trainer_show_last_number_of_runs then
            if (trainer_run_count - trainer_show_last_number_of_runs) ~= trainer_best_run then
                trainer_runs[trainer_run_count - trainer_show_last_number_of_runs] = nil
            end
        end
        
        print("trainer_segments_visited", trainer_segments_visited)
        print("message.numsegments", message.numsegments)
        
        if message.numsegments > trainer_segments_visited then
        
            print("trainer_waypoint_reached", message.waypoint)
            
            trainer_segments_visited = message.numsegments
            trainer_waypoint_reached = message.waypoint

            trainer_best_run_data = trainer_current_run
        
            self.waypoints = util.deepcopy(trainer_waypoints)
            
            print("Reached further than before (" .. tostring(trainer_waypoint_reached) .. "  segs: " .. tostring(message.numsegments) .."). Using as seed")
            
	        levelname = "main/levels/trainerrun.json"
	        trainer.save_data(levelname, trainer_current_run)
	        
        else
            --
        end
        trainer_current_run = {}
        
        reset_level(self, message.speed)
    end
end

function on_input(self, action_id, action)
	local playerid = 1
	playerinput.on_input(playerid, players[playerid], action_id, action)
	
	if action_id == hash("space") and action.pressed then
        self.pause = not self.pause
    end
	
	debugutil.on_input(self, action_id, action)
end
